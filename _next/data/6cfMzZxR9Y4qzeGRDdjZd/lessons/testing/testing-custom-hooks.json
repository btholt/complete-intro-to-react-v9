{"pageProps":{"post":{"attributes":{"description":"Learn how to test a custom React hook, usePizzaOfTheDay, by implementing a fake component and utilizing renderHook from testing-library/react. This approach ensures your hooks behave correctly, maintaining code integrity while interacting with APIs, like the example API call for \"Pizza of the Day.\"","keywords":["React testing","custom hooks","renderHook","testing-library","API testing"]},"html":"<p>Let&#39;s say we needs tests for our custom hook, usePizzaOfTheDay. Testing custom hooks is a bit of a trick because they are inherently tied to the internal workings of React: they can&#39;t be called outside of a component. So how we do we get around that? We fake a component! Make a file called <code>usePizzaOfTheDay.test.jsx</code> in our <code>__tests__</code> directory.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">import</span> { expect, test, vi } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;vitest&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { render } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@testing-library/react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> createFetchMock <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;vitest-fetch-mock&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { usePizzaOfTheDay } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;../usePizzaOfTheDay&quot;</span>;\n\n<span class=\"hljs-keyword\">const</span> fetchMocker = <span class=\"hljs-title function_\">createFetchMock</span>(vi);\nfetchMocker.<span class=\"hljs-title function_\">enableMocks</span>();\n\n<span class=\"hljs-keyword\">const</span> testPizza = {\n  <span class=\"hljs-attr\">id</span>: <span class=\"hljs-string\">&quot;calabrese&quot;</span>,\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;The Calabrese Pizza&quot;</span>,\n  <span class=\"hljs-attr\">category</span>: <span class=\"hljs-string\">&quot;Supreme&quot;</span>,\n  <span class=\"hljs-attr\">description</span>:\n    <span class=\"hljs-string\">&quot;Salami, Pancetta, Tomatoes, Red Onions, Friggitello Peppers, Garlic&quot;</span>,\n  <span class=\"hljs-attr\">image</span>: <span class=\"hljs-string\">&quot;/public/pizzas/calabrese.webp&quot;</span>,\n  <span class=\"hljs-attr\">sizes</span>: { <span class=\"hljs-attr\">S</span>: <span class=\"hljs-number\">12.25</span>, <span class=\"hljs-attr\">M</span>: <span class=\"hljs-number\">16.25</span>, <span class=\"hljs-attr\">L</span>: <span class=\"hljs-number\">20.25</span> },\n};\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getPizzaOfTheDay</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">let</span> pizza;\n\n  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">TestComponent</span>(<span class=\"hljs-params\"></span>) {\n    pizza = <span class=\"hljs-title function_\">usePizzaOfTheDay</span>();\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;\n  }\n\n  <span class=\"hljs-title function_\">render</span>(<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">TestComponent</span> /&gt;</span></span>);\n\n  <span class=\"hljs-keyword\">return</span> pizza;\n}\n\n<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&quot;gives null when first called&quot;</span>, <span class=\"hljs-title function_\">async</span> () =&gt; {\n  fetch.<span class=\"hljs-title function_\">mockResponseOnce</span>(<span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(testPizza));\n  <span class=\"hljs-keyword\">const</span> pizza = <span class=\"hljs-title function_\">getPizzaOfTheDay</span>();\n  <span class=\"hljs-title function_\">expect</span>(pizza).<span class=\"hljs-title function_\">toBeNull</span>();\n});\n</code></pre><p>It&#39;s a little weird to implement a fake component to test something (we&#39;re dangerously close to the line of testing implementation details) but this is essentially library code and we want to assure ourselves this code works if we use it frequently in our code base.</p>\n<p>We can make this better though. Let&#39;s rewrite our test to look like this:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">import</span> { renderHook } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@testing-library/react&quot;</span>; <span class=\"hljs-comment\">// change import</span>\n\n<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&quot;to be null on initial load&quot;</span>, <span class=\"hljs-title function_\">async</span> () =&gt; {\n  fetch.<span class=\"hljs-title function_\">mockResponseOnce</span>(<span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(testPizza));\n  <span class=\"hljs-keyword\">const</span> { result } = <span class=\"hljs-title function_\">renderHook</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">usePizzaOfTheDay</span>(<span class=\"hljs-string\">&quot;&quot;</span>));\n  <span class=\"hljs-title function_\">expect</span>(result.<span class=\"hljs-property\">current</span>).<span class=\"hljs-title function_\">toBeNull</span>();\n});\n</code></pre><p>Here the helper <code>renderHook</code> abstracts away that oddity we had to do to get that hook tested. But rest assured it&#39;s doing essentially the same thing: creating a component under the hood that&#39;s running the hook lifecycle methods appropriately for you.</p>\n<p>Let&#39;s add a test to make sure it does the right thing with the API response and calls the right API</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">import</span> { renderHook, waitFor } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@testing-library/react&quot;</span>; <span class=\"hljs-comment\">// add waitFor</span>\n\n<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&quot;to call the API and give back the pizza of the day&quot;</span>, <span class=\"hljs-title function_\">async</span> () =&gt; {\n  fetch.<span class=\"hljs-title function_\">mockResponseOnce</span>(<span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(testPizza));\n  <span class=\"hljs-keyword\">const</span> { result } = <span class=\"hljs-title function_\">renderHook</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">usePizzaOfTheDay</span>(<span class=\"hljs-string\">&quot;&quot;</span>));\n  <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">waitFor</span>(<span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-title function_\">expect</span>(result.<span class=\"hljs-property\">current</span>).<span class=\"hljs-title function_\">toEqual</span>(testPizza);\n  });\n  <span class=\"hljs-title function_\">expect</span>(fetchMocker).<span class=\"hljs-title function_\">toBeCalledWith</span>(<span class=\"hljs-string\">&quot;/api/pizza-of-the-day&quot;</span>);\n});\n</code></pre><ul>\n<li>waitFor is a handy trick where you need to wait for React to settle. You give it a body that throws errors until it&#39;s true. <code>expect</code> when it doesn&#39;t work throws an error so that&#39;s how this works.</li>\n<li>Once it resolves to true, it passes the test and moves on. If it fails like 20 times (that&#39;s configurable) it will then fail the test.</li>\n<li>Some people this is too into the implementation details and I half agree. However it is useful from the perspective that this hook needs to work in a certain way and it has an expectation of an API to call which does affect user behavior so it could be useful. If this was truly our codebase, I&#39;d just test the PizzaOfTheDay component and call it good. But if we used this hook in lots of places, I&#39;d probably a test just for it.</li>\n</ul>\n","markdown":"\nLet's say we needs tests for our custom hook, usePizzaOfTheDay. Testing custom hooks is a bit of a trick because they are inherently tied to the internal workings of React: they can't be called outside of a component. So how we do we get around that? We fake a component! Make a file called `usePizzaOfTheDay.test.jsx` in our `__tests__` directory.\n\n```javascript\nimport { expect, test, vi } from \"vitest\";\nimport { render } from \"@testing-library/react\";\nimport createFetchMock from \"vitest-fetch-mock\";\nimport { usePizzaOfTheDay } from \"../usePizzaOfTheDay\";\n\nconst fetchMocker = createFetchMock(vi);\nfetchMocker.enableMocks();\n\nconst testPizza = {\n  id: \"calabrese\",\n  name: \"The Calabrese Pizza\",\n  category: \"Supreme\",\n  description:\n    \"Salami, Pancetta, Tomatoes, Red Onions, Friggitello Peppers, Garlic\",\n  image: \"/public/pizzas/calabrese.webp\",\n  sizes: { S: 12.25, M: 16.25, L: 20.25 },\n};\n\nfunction getPizzaOfTheDay() {\n  let pizza;\n\n  function TestComponent() {\n    pizza = usePizzaOfTheDay();\n    return null;\n  }\n\n  render(<TestComponent />);\n\n  return pizza;\n}\n\ntest(\"gives null when first called\", async () => {\n  fetch.mockResponseOnce(JSON.stringify(testPizza));\n  const pizza = getPizzaOfTheDay();\n  expect(pizza).toBeNull();\n});\n```\n\nIt's a little weird to implement a fake component to test something (we're dangerously close to the line of testing implementation details) but this is essentially library code and we want to assure ourselves this code works if we use it frequently in our code base.\n\nWe can make this better though. Let's rewrite our test to look like this:\n\n```javascript\nimport { renderHook } from \"@testing-library/react\"; // change import\n\ntest(\"to be null on initial load\", async () => {\n  fetch.mockResponseOnce(JSON.stringify(testPizza));\n  const { result } = renderHook(() => usePizzaOfTheDay(\"\"));\n  expect(result.current).toBeNull();\n});\n```\n\nHere the helper `renderHook` abstracts away that oddity we had to do to get that hook tested. But rest assured it's doing essentially the same thing: creating a component under the hood that's running the hook lifecycle methods appropriately for you.\n\nLet's add a test to make sure it does the right thing with the API response and calls the right API\n\n```javascript\nimport { renderHook, waitFor } from \"@testing-library/react\"; // add waitFor\n\ntest(\"to call the API and give back the pizza of the day\", async () => {\n  fetch.mockResponseOnce(JSON.stringify(testPizza));\n  const { result } = renderHook(() => usePizzaOfTheDay(\"\"));\n  await waitFor(() => {\n    expect(result.current).toEqual(testPizza);\n  });\n  expect(fetchMocker).toBeCalledWith(\"/api/pizza-of-the-day\");\n});\n```\n\n- waitFor is a handy trick where you need to wait for React to settle. You give it a body that throws errors until it's true. `expect` when it doesn't work throws an error so that's how this works.\n- Once it resolves to true, it passes the test and moves on. If it fails like 20 times (that's configurable) it will then fail the test.\n- Some people this is too into the implementation details and I half agree. However it is useful from the perspective that this hook needs to work in a certain way and it has an expectation of an API to call which does affect user behavior so it could be useful. If this was truly our codebase, I'd just test the PizzaOfTheDay component and call it good. But if we used this hook in lots of places, I'd probably a test just for it.\n","slug":"testing-custom-hooks","title":"Testing Custom Hooks","section":"Testing","icon":"vial","filePath":"/home/runner/work/complete-intro-to-react-v9/complete-intro-to-react-v9/lessons/07-testing/D-testing-custom-hooks.md","nextSlug":"/lessons/testing/snapshot-testing","prevSlug":"/lessons/testing/testing-user-interaction"}},"__N_SSG":true}