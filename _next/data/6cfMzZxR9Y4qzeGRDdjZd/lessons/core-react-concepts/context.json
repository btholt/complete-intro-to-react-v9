{"pageProps":{"post":{"attributes":{"description":"Learn how to manage global state in a React application by implementing a shopping cart using context. This tutorial, part of the Complete Intro to React v9 course by Brian Holt, guides you in creating reusable components and sharing state across the application without prop drilling, enhancing your React skills with practical examples.","keywords":["React","shopping cart","context API","global state","Brian Holt"]},"html":"<h2>Context</h2>\n<p>Let&#39;s make a cart indicator on the top right of the page. Create a file called Header.jsx and put this in there.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Header</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">nav</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;logo&quot;</span>&gt;</span>Padre Gino&#x27;s Pizza<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;nav-cart&quot;</span>&gt;</span>\n        🛒<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;nav-cart-number&quot;</span>&gt;</span>5<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">nav</span>&gt;</span></span>\n  );\n}\n</code></pre><p>Now let&#39;s use that in App.jsx</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// at top</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Header</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./Header&quot;</span>;\n\n<span class=\"hljs-comment\">// replace .logo</span>\n<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Header</span> /&gt;</span></span>\n</code></pre><p>Right now this will always show 5 but we want that number in .nav-cart-number to reflect how many items we have in our cart. How would we do that? We could move all of cart and its hooks to App.jsx and pass it into both Header and Order. In an app this small, that could be the right choice. But let&#39;s look at another way to do it, context.</p>\n<p>Context is for app-level state. This is state that exists for your entire app. The currently logged in user would be a good example of this. You wouldn&#39;t want the user to exist in just the page level because once you navigate to another page, all state of the previous page is destroyed. You&#39;d want that user info to persist between pages, and thus context is a good thing for that. Context allows you to keep a global state for your app. We&#39;re going to use it for the shopping cart which actually makes good sense: if a user navigates to another page, you&#39;d want to keep their shopping cart between loads. This is a good way to think about when you may want to use context: if you want that stage to persist between pages.</p>\n<p>So let&#39;s make it work. Make a file called <code>contexts.jsx</code>. It&#39;s not a component so I tend to not capitalize it. The React docs do capitalize it. Up to you.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">import</span> { createContext } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">CartContext</span> = <span class=\"hljs-title function_\">createContext</span>([[], <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {}]);\n</code></pre><p>That&#39;s it. Pretty simple. It&#39;s called contexts with an <code>s</code> because if you had other contexts (like a UserContext) you could put those all in the same file. The <code>[[], function () {}]</code> isn&#39;t strictly necessary; it&#39;s a default value your context would use if no context provider is there (which should never happen.) This really only ends up being useful for TypeScript types – the type you give here is what TypeScript will use to validate it. In theory it could be helpful for testing too. The reason for the weird value is that it&#39;s a React hook: an array where the first value is an array (like our cart is) and the second value is a function (the setCart function).</p>\n<p>Okay, let&#39;s go put it in App.jsx.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// at the top</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">StrictMode</span>, useState } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>; <span class=\"hljs-comment\">// need useState</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">CartContext</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./contexts&quot;</span>;\n\n<span class=\"hljs-comment\">// replace App</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">App</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n  <span class=\"hljs-keyword\">const</span> cartHook = <span class=\"hljs-title function_\">useState</span>([]);\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">StrictMode</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">CartContext.Provider</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{cartHook}</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Header</span> /&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Order</span> /&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">PizzaOfTheDay</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">CartContext.Provider</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">StrictMode</span>&gt;</span></span>\n  );\n};\n</code></pre><p>We&#39;re creating a hook (notice we are not destructuring) and passing that in as the value. The Provider makes that context available only inside of its children. In theory you could have multiple providers from the same context but honestly I&#39;ve never had a reason to do it.</p>\n<p>Alright, let&#39;s go make Order.jsx work now.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// at top</span>\n<span class=\"hljs-keyword\">import</span> { useState, useEffect, useContext } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>; <span class=\"hljs-comment\">// need useContext</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">CartContext</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./contexts&quot;</span>;\n\n<span class=\"hljs-keyword\">const</span> [cart, setCart] = <span class=\"hljs-title function_\">useContext</span>(<span class=\"hljs-title class_\">CartContext</span>); <span class=\"hljs-comment\">// change cart hook to use context</span>\n</code></pre><p>That&#39;s it! Everything else works the same. In our case we&#39;re just using a hook directly from context, but you can put anything in context; it doesn&#39;t have to be a hook.</p>\n<p>Let&#39;s go use it in our Header now too.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// at top</span>\n<span class=\"hljs-keyword\">import</span> { useContext } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">CartContext</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./contexts&quot;</span>;\n\n<span class=\"hljs-comment\">// top of function</span>\n<span class=\"hljs-keyword\">const</span> [cart] = <span class=\"hljs-title function_\">useContext</span>(<span class=\"hljs-title class_\">CartContext</span>);\n\n<span class=\"hljs-comment\">// replace span number</span>\n🛒&lt;span className=<span class=\"hljs-string\">&quot;nav-cart-number&quot;</span>&gt;{cart.<span class=\"hljs-property\">length</span>}&lt;/span&gt;\n</code></pre><p>That&#39;s it! We don&#39;t need the setCart function so we don&#39;t import that. Otherwise all looks pretty normal!</p>\n<p>So that&#39;s context. It&#39;s super useful for stuff like this where we don&#39;t want to &quot;prop drill&quot; our state everywhere. Since cart is now being held at the App level, we definitely could have just said <code>&lt;Header cart={cart} /&gt;</code> and called it a day, and in this specific use case I would have. But now imagine if Header was super deeply nested and you had to pass that state down a lot of children components – it gets messy quickly. This is what we call prop drilling. React&#39;s explicit data flow is a feature, not a bug. It makes where data came from and where data is going very readable. But it can make your code verbose in a non-helpful way, and context is an escape hatch for that. In general, use context sparingly and only where it&#39;s <em>really</em> inconvenient to just do it the normal way of using props.</p>\n<blockquote>\n<p>🏁 <a href=\"https://github.com/btholt/citr-v9-project/tree/master/08-context\">Click here to see the state of the project up until now: 08-context</a></p>\n</blockquote>\n","markdown":"\n## Context\n\nLet's make a cart indicator on the top right of the page. Create a file called Header.jsx and put this in there.\n\n```javascript\nexport default function Header() {\n  return (\n    <nav>\n      <h1 className=\"logo\">Padre Gino's Pizza</h1>\n      <div className=\"nav-cart\">\n        🛒<span className=\"nav-cart-number\">5</span>\n      </div>\n    </nav>\n  );\n}\n```\n\nNow let's use that in App.jsx\n\n```javascript\n// at top\nimport Header from \"./Header\";\n\n// replace .logo\n<Header />\n```\n\nRight now this will always show 5 but we want that number in .nav-cart-number to reflect how many items we have in our cart. How would we do that? We could move all of cart and its hooks to App.jsx and pass it into both Header and Order. In an app this small, that could be the right choice. But let's look at another way to do it, context.\n\nContext is for app-level state. This is state that exists for your entire app. The currently logged in user would be a good example of this. You wouldn't want the user to exist in just the page level because once you navigate to another page, all state of the previous page is destroyed. You'd want that user info to persist between pages, and thus context is a good thing for that. Context allows you to keep a global state for your app. We're going to use it for the shopping cart which actually makes good sense: if a user navigates to another page, you'd want to keep their shopping cart between loads. This is a good way to think about when you may want to use context: if you want that stage to persist between pages.\n\nSo let's make it work. Make a file called `contexts.jsx`. It's not a component so I tend to not capitalize it. The React docs do capitalize it. Up to you.\n\n```javascript\nimport { createContext } from \"react\";\n\nexport const CartContext = createContext([[], function () {}]);\n```\n\nThat's it. Pretty simple. It's called contexts with an `s` because if you had other contexts (like a UserContext) you could put those all in the same file. The `[[], function () {}]` isn't strictly necessary; it's a default value your context would use if no context provider is there (which should never happen.) This really only ends up being useful for TypeScript types – the type you give here is what TypeScript will use to validate it. In theory it could be helpful for testing too. The reason for the weird value is that it's a React hook: an array where the first value is an array (like our cart is) and the second value is a function (the setCart function).\n\nOkay, let's go put it in App.jsx.\n\n```javascript\n// at the top\nimport { StrictMode, useState } from \"react\"; // need useState\nimport { CartContext } from \"./contexts\";\n\n// replace App\nconst App = () => {\n  const cartHook = useState([]);\n  return (\n    <StrictMode>\n      <CartContext.Provider value={cartHook}>\n        <div>\n          <Header />\n          <Order />\n          <PizzaOfTheDay />\n        </div>\n      </CartContext.Provider>\n    </StrictMode>\n  );\n};\n```\n\nWe're creating a hook (notice we are not destructuring) and passing that in as the value. The Provider makes that context available only inside of its children. In theory you could have multiple providers from the same context but honestly I've never had a reason to do it.\n\nAlright, let's go make Order.jsx work now.\n\n```javascript\n// at top\nimport { useState, useEffect, useContext } from \"react\"; // need useContext\nimport { CartContext } from \"./contexts\";\n\nconst [cart, setCart] = useContext(CartContext); // change cart hook to use context\n```\n\nThat's it! Everything else works the same. In our case we're just using a hook directly from context, but you can put anything in context; it doesn't have to be a hook.\n\nLet's go use it in our Header now too.\n\n```javascript\n// at top\nimport { useContext } from \"react\";\nimport { CartContext } from \"./contexts\";\n\n// top of function\nconst [cart] = useContext(CartContext);\n\n// replace span number\n🛒<span className=\"nav-cart-number\">{cart.length}</span>\n```\n\nThat's it! We don't need the setCart function so we don't import that. Otherwise all looks pretty normal!\n\nSo that's context. It's super useful for stuff like this where we don't want to \"prop drill\" our state everywhere. Since cart is now being held at the App level, we definitely could have just said `<Header cart={cart} />` and called it a day, and in this specific use case I would have. But now imagine if Header was super deeply nested and you had to pass that state down a lot of children components – it gets messy quickly. This is what we call prop drilling. React's explicit data flow is a feature, not a bug. It makes where data came from and where data is going very readable. But it can make your code verbose in a non-helpful way, and context is an escape hatch for that. In general, use context sparingly and only where it's _really_ inconvenient to just do it the normal way of using props.\n\n> 🏁 [Click here to see the state of the project up until now: 08-context][step]\n\n[step]: https://github.com/btholt/citr-v9-project/tree/master/08-context\n","slug":"context","title":"Context","section":"Core React Concepts","icon":"book","filePath":"/home/runner/work/complete-intro-to-react-v9/complete-intro-to-react-v9/lessons/04-core-react-concepts/G-context.md","nextSlug":"/lessons/ecosystem/tanstack-router","prevSlug":"/lessons/core-react-concepts/handling-user-inputs"}},"__N_SSG":true}