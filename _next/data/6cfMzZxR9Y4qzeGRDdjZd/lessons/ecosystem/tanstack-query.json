{"pageProps":{"post":{"attributes":{"title":"TanStack Query","description":"Learn how to create a past orders page in React using TanStack Query to facilitate seamless asynchronous API calls, enhancing code cleanliness and efficiency. This guide by seasoned developer Brian Holt provides detailed instructions on integrating React Query ESLint configurations and leveraging React Query Devtools for better debugging. Ideal for web developers looking to optimize React-based projects with effective data fetching techniques.","keywords":["React","TanStack Query","API calls","web development","JavaScript","Brian Holt"]},"html":"<h2>Tanstack Query</h2>\n<p>Let&#39;s make make a past orders page. Create a new file, <code>past.lazy.jsx</code>. If your Vite server is already running, it will automatically stub it out for you! Pretty cool developer experience from TanStack.</p>\n<p>Now let&#39;s install our next tool, <a href=\"https://tanstack.com/query/latest\">TanStack (React) Query</a>.</p>\n<pre><code class=\"hljs language-bash\">npm i @tanstack/react-query@5.59.13\nnpm i -D @tanstack/react-query-devtools@5.59.13 @tanstack/eslint-plugin-query@5.59.7\n</code></pre><p>React Query makes doing async API calls so much easier. So much easier / better, that I almost never use <code>useEffect</code> anymore like we did for the pizzas list or for the pizza of the day. The code is cleaner, easier to read, better cached, and less bug prone. In short, it&#39;s just better. It&#39;s good for you to know how to use effects, but as you go forward just use TanStack Query for API calls.</p>\n<p>Let&#39;s get started. Let&#39;s start by adding their ESLint config to ours. They have some useful rules in there. In eslint.config.mjs</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// at top</span>\n<span class=\"hljs-keyword\">import</span> pluginQuery <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@tanstack/eslint-plugin-query&quot;</span>;\n\n<span class=\"hljs-comment\">// under reactPlugin.configs.flat[&quot;jsx-runtime&quot;]</span>\n...pluginQuery.<span class=\"hljs-property\">configs</span>[<span class=\"hljs-string\">&quot;flat/recommended&quot;</span>],\n</code></pre><p>This will add a few rules to your ESLint that are specific to React Query. I have found these helpful, and more importantly, not annoying, so I tend to add them every time.</p>\n<p>Let&#39;s also add the dev tools, like we did for the router. In <code>src/routes/__root.jsx</code>:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// at top</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">ReactQueryDevtools</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@tanstack/react-query-devtools&quot;</span>;\n\n<span class=\"hljs-comment\">// under router dev tools</span>\n<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ReactQueryDevtools</span> /&gt;</span></span>\n</code></pre><p>Finally, we need to add the <code>QueryClient</code>. In <code>App.jsx</code>, add:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// Add imports</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">QueryClient</span>, <span class=\"hljs-title class_\">QueryClientProvider</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@tanstack/react-query&quot;</span>;\n\n<span class=\"hljs-comment\">// Create a property under the router</span>\n<span class=\"hljs-keyword\">const</span> queryClient = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">QueryClient</span>()\n\n<span class=\"hljs-comment\">// Add the provider to the app</span>\n&lt;<span class=\"hljs-title class_\">QueryClientProvider</span> client={queryClient}&gt;\n  <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">RouterProvider</span> <span class=\"hljs-attr\">router</span>=<span class=\"hljs-string\">{router}</span> /&gt;</span></span>\n&lt;/<span class=\"hljs-title class_\">QueryClientProvider</span>&gt;\n</code></pre><p>Now in the bottom right of your window you&#39;ll see a üèùÔ∏è. Click on that and we&#39;ll open the dev tools. We haven&#39;t used the dev tools yet so it&#39;ll be empty.</p>\n<p>So react-query makes interacting with APIs very simple and makes it easy to read. You just read a hook and it&#39;ll either give you a <code>isLoading</code> status or the data. Once the data comes back, it&#39;ll refresh the component with the data. So let&#39;s start by writing our very simple fetch call. Create a folder called <code>api</code> inside of <code>src</code> and create <code>getPastOrders.js</code> and add:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getPastOrders</span>(<span class=\"hljs-params\">page</span>) {\n  <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">`/api/past-orders?page=<span class=\"hljs-subst\">${page}</span>`</span>);\n  <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">await</span> response.<span class=\"hljs-title function_\">json</span>();\n  <span class=\"hljs-keyword\">return</span> data;\n}\n</code></pre><p>Very simple request to an API that returns data. That&#39;s it!</p>\n<p>Let&#39;s now go make <code>past.lazy.jsx</code>.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">import</span> { useState } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { useQuery } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@tanstack/react-query&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { createLazyFileRoute } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@tanstack/react-router&quot;</span>;\n<span class=\"hljs-keyword\">import</span> getPastOrders <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;../api/getPastOrders&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Route</span> = <span class=\"hljs-title function_\">createLazyFileRoute</span>(<span class=\"hljs-string\">&quot;/past&quot;</span>)({\n  <span class=\"hljs-attr\">component</span>: <span class=\"hljs-title class_\">PastOrdersRoute</span>,\n});\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">PastOrdersRoute</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> [page, setPage] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">1</span>);\n  <span class=\"hljs-keyword\">const</span> { isLoading, data } = <span class=\"hljs-title function_\">useQuery</span>({\n    <span class=\"hljs-attr\">queryKey</span>: [<span class=\"hljs-string\">&quot;past-orders&quot;</span>, page],\n    <span class=\"hljs-attr\">queryFn</span>: <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">getPastOrders</span>(page),\n    <span class=\"hljs-attr\">staleTime</span>: <span class=\"hljs-number\">30000</span>,\n  });\n  <span class=\"hljs-keyword\">if</span> (isLoading) {\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;past-orders&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span>LOADING ‚Ä¶<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n    );\n  }\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;past-orders&quot;</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">table</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">thead</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>ID<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>Date<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>Time<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tr</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">thead</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tbody</span>&gt;</span>\n          {data.map((order) =&gt; (\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">{order.order_id}</span>&gt;</span>\n              <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>{order.order_id}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span>\n              <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>{order.date}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span>\n              <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>{order.time}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tr</span>&gt;</span>\n          ))}\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tbody</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">table</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;pages&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">disabled</span>=<span class=\"hljs-string\">{page</span> &lt;= <span class=\"hljs-string\">1}</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> setPage(page - 1)}&gt;\n          Previous\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>{page}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">disabled</span>=<span class=\"hljs-string\">{data.length</span> &lt; <span class=\"hljs-attr\">10</span>} <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> setPage(page + 1)}&gt;\n          Next\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n}\n</code></pre><ul>\n<li>We&#39;re using hooks to track the page we&#39;re on.</li>\n<li>We&#39;re using the useQuery hook to make API calls and we provide it the queryFn of how to go fetch that data.</li>\n<li>We&#39;re giving it keys which act as cache keys. We&#39;re giving <code>past-orders</code> as the key but it could be any unique key to this page. Then we give it the page. What&#39;s cool about this is that while we will request the page 1 the first time we request it, the second time we request page 1 it&#39;ll see it&#39;ll see that we already have this in cache and not request it. How cool is is that? That used to require so much logic to handle it and now React Query just does it for you.</li>\n<li>Now open the dev tools. You can see all the pages being loaded in. Pretty cool, right?</li>\n<li>Try taking out <code>page</code> from the query key. It&#39;ll yell at you. This is the ESLint config we pulled in from Tanstack Query. Because we&#39;re using that <code>page</code> in the request, we need to use it as a caching key. If you depend on a variable to make a request, it should be apart of the caching key.</li>\n<li>We&#39;re giving it a <code>staleTime</code> of 30 seconds (30,000 milliseconds). This allows someone using the page to browse around a bit and not bombard the API too much but the page won&#39;t ever be too stale. If you omit <code>staleTime</code>, it will refetch every time.</li>\n</ul>\n<p>That&#39;s it! React Query is both simple to use and super flexible to handle a tough problem. It&#39;s one of my favorite libraries for React.</p>\n<blockquote>\n<p>üèÅ <a href=\"https://github.com/btholt/citr-v9-project/tree/master/10-query\">Click here to see the state of the project up until now: 10-query</a></p>\n</blockquote>\n","markdown":"\n## Tanstack Query\n\nLet's make make a past orders page. Create a new file, `past.lazy.jsx`. If your Vite server is already running, it will automatically stub it out for you! Pretty cool developer experience from TanStack.\n\nNow let's install our next tool, [TanStack (React) Query][tsq].\n\n```bash\nnpm i @tanstack/react-query@5.59.13\nnpm i -D @tanstack/react-query-devtools@5.59.13 @tanstack/eslint-plugin-query@5.59.7\n```\n\nReact Query makes doing async API calls so much easier. So much easier / better, that I almost never use `useEffect` anymore like we did for the pizzas list or for the pizza of the day. The code is cleaner, easier to read, better cached, and less bug prone. In short, it's just better. It's good for you to know how to use effects, but as you go forward just use TanStack Query for API calls.\n\nLet's get started. Let's start by adding their ESLint config to ours. They have some useful rules in there. In eslint.config.mjs\n\n```javascript\n// at top\nimport pluginQuery from \"@tanstack/eslint-plugin-query\";\n\n// under reactPlugin.configs.flat[\"jsx-runtime\"]\n...pluginQuery.configs[\"flat/recommended\"],\n```\n\nThis will add a few rules to your ESLint that are specific to React Query. I have found these helpful, and more importantly, not annoying, so I tend to add them every time.\n\nLet's also add the dev tools, like we did for the router. In `src/routes/__root.jsx`:\n\n```javascript\n// at top\nimport { ReactQueryDevtools } from \"@tanstack/react-query-devtools\";\n\n// under router dev tools\n<ReactQueryDevtools />\n```\n\nFinally, we need to add the `QueryClient`. In `App.jsx`, add:\n\n```javascript\n// Add imports\nimport { QueryClient, QueryClientProvider } from \"@tanstack/react-query\";\n\n// Create a property under the router\nconst queryClient = new QueryClient()\n\n// Add the provider to the app\n<QueryClientProvider client={queryClient}>\n  <RouterProvider router={router} />\n</QueryClientProvider>\n```\n\nNow in the bottom right of your window you'll see a üèùÔ∏è. Click on that and we'll open the dev tools. We haven't used the dev tools yet so it'll be empty.\n\nSo react-query makes interacting with APIs very simple and makes it easy to read. You just read a hook and it'll either give you a `isLoading` status or the data. Once the data comes back, it'll refresh the component with the data. So let's start by writing our very simple fetch call. Create a folder called `api` inside of `src` and create `getPastOrders.js` and add:\n\n```javascript\nexport default async function getPastOrders(page) {\n  const response = await fetch(`/api/past-orders?page=${page}`);\n  const data = await response.json();\n  return data;\n}\n```\n\nVery simple request to an API that returns data. That's it!\n\nLet's now go make `past.lazy.jsx`.\n\n```javascript\nimport { useState } from \"react\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { createLazyFileRoute } from \"@tanstack/react-router\";\nimport getPastOrders from \"../api/getPastOrders\";\n\nexport const Route = createLazyFileRoute(\"/past\")({\n  component: PastOrdersRoute,\n});\n\nfunction PastOrdersRoute() {\n  const [page, setPage] = useState(1);\n  const { isLoading, data } = useQuery({\n    queryKey: [\"past-orders\", page],\n    queryFn: () => getPastOrders(page),\n    staleTime: 30000,\n  });\n  if (isLoading) {\n    return (\n      <div className=\"past-orders\">\n        <h2>LOADING ‚Ä¶</h2>\n      </div>\n    );\n  }\n  return (\n    <div className=\"past-orders\">\n      <table>\n        <thead>\n          <tr>\n            <td>ID</td>\n            <td>Date</td>\n            <td>Time</td>\n          </tr>\n        </thead>\n        <tbody>\n          {data.map((order) => (\n            <tr key={order.order_id}>\n              <td>{order.order_id}</td>\n              <td>{order.date}</td>\n              <td>{order.time}</td>\n            </tr>\n          ))}\n        </tbody>\n      </table>\n      <div className=\"pages\">\n        <button disabled={page <= 1} onClick={() => setPage(page - 1)}>\n          Previous\n        </button>\n        <div>{page}</div>\n        <button disabled={data.length < 10} onClick={() => setPage(page + 1)}>\n          Next\n        </button>\n      </div>\n    </div>\n  );\n}\n```\n\n- We're using hooks to track the page we're on.\n- We're using the useQuery hook to make API calls and we provide it the queryFn of how to go fetch that data.\n- We're giving it keys which act as cache keys. We're giving `past-orders` as the key but it could be any unique key to this page. Then we give it the page. What's cool about this is that while we will request the page 1 the first time we request it, the second time we request page 1 it'll see it'll see that we already have this in cache and not request it. How cool is is that? That used to require so much logic to handle it and now React Query just does it for you.\n- Now open the dev tools. You can see all the pages being loaded in. Pretty cool, right?\n- Try taking out `page` from the query key. It'll yell at you. This is the ESLint config we pulled in from Tanstack Query. Because we're using that `page` in the request, we need to use it as a caching key. If you depend on a variable to make a request, it should be apart of the caching key.\n- We're giving it a `staleTime` of 30 seconds (30,000 milliseconds). This allows someone using the page to browse around a bit and not bombard the API too much but the page won't ever be too stale. If you omit `staleTime`, it will refetch every time.\n\nThat's it! React Query is both simple to use and super flexible to handle a tough problem. It's one of my favorite libraries for React.\n\n> üèÅ [Click here to see the state of the project up until now: 10-query][step]\n\n[step]: https://github.com/btholt/citr-v9-project/tree/master/10-query\n[tsq]: https://tanstack.com/query/latest\n","slug":"tanstack-query","title":"TanStack Query","section":"Ecosystem","icon":"seedling","filePath":"/home/runner/work/complete-intro-to-react-v9/complete-intro-to-react-v9/lessons/05-ecosystem/B-tanstack-query.md","nextSlug":"/lessons/advanced-react/portals","prevSlug":"/lessons/ecosystem/tanstack-router"}},"__N_SSG":true}